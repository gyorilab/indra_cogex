{% extends 'data_display_base.html' %}

{% block network_head %}
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.css">
    <style>
    /* Details dialog for edges and nodes */
    .details-dialog {
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 15px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 1000;
        min-width: 300px;
        max-width: 400px;
    }

    .details-dialog .close-btn {
        position: absolute;
        right: 10px;
        top: 10px;
        cursor: pointer;
        font-size: 18px;
        color: #999;
    }

    .details-dialog h3 {
        margin-top: 0;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
        margin-bottom: 10px;
    }

    .details-dialog dl {
        margin: 0;
    }

    .details-dialog dt {
        font-weight: bold;
        margin-top: 8px;
    }

    .details-dialog dd {
        margin-left: 0;
        margin-bottom: 5px;
    }

    .details-dialog a {
        color: blue;
        text-decoration: none;
    }

    .details-dialog a:hover {
        text-decoration: underline;
    }
    </style>
{% endblock %}

{% block network_content %}
    {% if prefix in ['pubmed', 'pmid', 'pmc', 'doi', 'go', 'subnetwork', 'statements'] %}
        {% include 'data_display/_network_visualization.html' %}
    {% endif %}
{% endblock %}

{% block network_scripts %}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const prefix = '{{ prefix }}';
        const identifier = '{{ identifier }}';

        console.log("Document loaded. Prefix:", prefix, "Identifier:", identifier);

        // Check if this is a statements view
        if (prefix === 'statements') {
            // Get statement parameters from template
            const genes = {{ genes|tojson if genes else '[]' }};
            const isDownstream = {{ is_downstream|tojson if is_downstream is defined else 'false' }};
            const regulatorType = {{ regulator_type|tojson if regulator_type else 'null' }};
            const minBelief = {{ minimum_belief|default(0.0) }};
            const minEvidence = {{ minimum_evidence|default(2) }};

            // Initialize network for statements
            initializeStatementsNetwork(identifier, genes, minBelief, minEvidence, isDownstream, regulatorType);
        } else {
            // Regular explorer initialization
            initializeNetwork(prefix, identifier);
        }

        // Toggle network visibility
        const toggleBtn = document.getElementById('toggle-network');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', function() {
                const container = document.getElementById('network-container');
                if (container.style.display === 'none') {
                    container.style.display = 'block';
                    this.textContent = 'Hide Network';
                } else {
                    container.style.display = 'none';
                    this.textContent = 'Show Network';
                }
            });
        }

        // Reset button functionality
        const resetBtn = document.getElementById('reset-network');
        if (resetBtn) {
            resetBtn.addEventListener('click', function() {
                if (window.networkInstance) {
                    window.networkInstance.fit({
                        animation: {
                            duration: 1000,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                }
            });
        }
    });

    function initializeNetwork(prefix, identifier) {
        console.log("initializeNetwork called with:", prefix, identifier);

        const container = document.getElementById('network-container');
        if (!container) {
            console.error("Network container not found!");
            return;
        }

        // Show loading indicator
        container.innerHTML = '<div class="d-flex justify-content-center align-items-center" style="height: 100%;">' +
                             '<div class="spinner-border text-primary" role="status"></div>' +
                             '<span class="ml-2">Loading network...</span>' +
                             '</div>';

        // Get the current include_db_evidence value from Vue
        const includeDbEvidence = app.include_db_evidence;
        console.log("include_db_evidence:", includeDbEvidence);

        // Determine which API to use based on prefix
        let fetchUrl = '/api/get_network';
        let payload;

        if (prefix === 'go') {
            payload = {
                network_type: 'go',
                identifier: identifier,
                include_db_evidence: includeDbEvidence,
                limit: 25
            };
        }
        else if (prefix === 'subnetwork') {
            const nodes = identifier.split(',').map(item => {
                const [ns, id] = item.split(':');
                return [ns, id];
            });
            payload = {
                network_type: 'subnetwork',
                identifier: nodes,
                include_db_evidence: includeDbEvidence,
                limit: 25
            };
        }
        else {
            payload = {
                network_type: 'paper',
                identifier: [prefix, identifier],
                include_db_evidence: includeDbEvidence,
                limit: 25
            };
        }

        // Call the API to get network data
        fetch(fetchUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (!data.nodes || data.nodes.length === 0) {
                let noDataMessage = 'No network data available';
                if (prefix === 'go') {
                    noDataMessage += ' for this GO term.';
                } else if (prefix === 'subnetwork') {
                    noDataMessage += ' for this subnetwork.';
                } else {
                    noDataMessage += ' for this paper.';
                }
                container.innerHTML = `<div class="alert alert-info">${noDataMessage}</div>`;
                return;
            }

            // Create the network
            createNetworkVisualization(container, data);
        })
        .catch(error => {
            console.error('Error fetching network data:', error);
            container.innerHTML = '<div class="alert alert-danger">Error loading network visualization. Please try again later.</div>';
        });
    }

    function initializeStatementsNetwork(targetId, genes, minBelief, minEvidence, isDownstream, regulatorType) {
        console.log("initializeStatementsNetwork called with:", targetId, genes.length, "genes");

        const container = document.getElementById('network-container');
        if (!container) {
            console.error("Network container not found!");
            return;
        }

        // Show loading indicator
        container.innerHTML = '<div class="d-flex justify-content-center align-items-center" style="height: 100%;">' +
                             '<div class="spinner-border text-primary" role="status"></div>' +
                             '<span class="ml-2">Loading network...</span>' +
                             '</div>';

        // Call the statements network API
        fetch('/api/get_network_for_statements', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                target_id: targetId,
                genes: genes,
                minimum_belief: minBelief,
                minimum_evidence: minEvidence,
                is_downstream: isDownstream,
                regulator_type: regulatorType,
                limit: 50
            })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.nodes || data.nodes.length === 0) {
                container.innerHTML = '<div class="alert alert-info">No network data available for these statements.</div>';
                return;
            }

            // Create the network
            createNetworkVisualization(container, data);
        })
        .catch(error => {
            console.error('Error fetching network data:', error);
            container.innerHTML = '<div class="alert alert-danger">Error loading network visualization. Please try again later.</div>';
        });
    }

    // Shared function to create network visualization
    function createNetworkVisualization(container, data) {
        const nodes = new vis.DataSet(data.nodes);
        const edges = new vis.DataSet(data.edges);

        const options = {
            nodes: {
                shape: 'ellipse',
                size: 60,
                font: {
                    color: '#000000',
                    size: 26,
                    face: 'arial',
                    vadjust: -40,
                    bold: true
                },
                borderWidth: 3,
                shadow: true
            },
            edges: {
                arrows: {
                    to: { enabled: true, scaleFactor: 0.5 }
                },
                font: {
                    size: 0,
                    align: 'middle',
                    color: '#333333',
                    strokeWidth: 0
                },
                width: 5,
                smooth: {
                    enabled: true,
                    type: 'dynamic'
                },
                shadow: true
            },
            physics: {
                enabled: true,
                barnesHut: {
                    gravitationalConstant: -8000,
                    centralGravity: 0.05,
                    springLength: 350,
                    springConstant: 0.03
                },
                stabilization: {
                    enabled: true,
                    iterations: 2000
                }
            },
            interaction: {
                hover: true,
                tooltipDelay: 200,
                zoomView: true,
                dragView: true,
                selectable: true,
                selectConnectedEdges: true,
                hoverConnectedEdges: true
            },
            layout: {
                improvedLayout: true,
            }
        };

        // Initialize the network
        const network = new vis.Network(container, { nodes, edges }, options);

        // Store network instance globally for access by reset button
        window.networkInstance = network;

        // Force a more spread out layout
        network.setOptions({
            physics: {
                enabled: true,
                stabilization: {
                    enabled: true,
                    iterations: 2000
                }
            }
        });

        // Start over with stabilization
        network.stabilize(2000);

        network.once('stabilizationIterationsDone', function() {
            network.moveTo({
                scale: 0.65,
                animation: {
                    duration: 1000,
                    easingFunction: 'easeInOutQuad'
                }
            });
        });

        // Create and manage the details dialog
        setupNetworkInteractions(network, nodes, edges);
    }

    // Setup network event handlers
    function setupNetworkInteractions(network, nodes, edges) {
        let detailsDialog = null;

        // Handle clicks - Check nodes FIRST, then edges
        network.on("click", function(params) {
            // If a node was clicked
            if (params.nodes && params.nodes.length > 0) {
                showNodeDetails(network, nodes, params.nodes[0]);
            }
            // If an edge was clicked
            else if (params.edges && params.edges.length > 0) {
                showEdgeDetails(network, edges, params.edges[0]);
            }
            // If clicking elsewhere, close dialog
            else if (detailsDialog && !params.event.srcElement.closest('.details-dialog')) {
                document.body.removeChild(detailsDialog);
                detailsDialog = null;
            }
        });

        // Double-click to highlight connections
        network.on("doubleClick", function(params) {
            if (params.nodes.length > 0) {
                highlightConnections(network, nodes, edges, params.nodes[0]);
            } else {
                resetHighlighting(nodes, edges);
            }
        });

        function showNodeDetails(network, nodes, nodeId) {
            if (detailsDialog) {
                document.body.removeChild(detailsDialog);
            }

            detailsDialog = document.createElement('div');
            detailsDialog.className = 'details-dialog';

            const nodeData = nodes.get(nodeId);
            const details = nodeData.details || {};

            let dialogContent = `
                <span class="close-btn">×</span>
                <h3>${nodeData.label}</h3>
                <dl>
                    <dt>ID</dt>
                    <dd>${nodeData.id || 'Unknown'}</dd>
                    <dt>Type</dt>
                    <dd>${nodeData.type || 'Unknown'}</dd>
            `;

            if (nodeData.hgnc) {
                dialogContent += `
                    <dt>HGNC</dt>
                    <dd><a href="https://identifiers.org/hgnc:${nodeData.hgnc}" target="_blank">https://identifiers.org/hgnc:${nodeData.hgnc}</a></dd>
                `;
            }

            if (nodeData.egid) {
                dialogContent += `
                    <dt>EGID</dt>
                    <dd><a href="https://identifiers.org/ncbigene:${nodeData.egid}" target="_blank">https://identifiers.org/ncbigene:${nodeData.egid}</a></dd>
                `;
            }

            if (nodeData.uniprot) {
                dialogContent += `
                    <dt>UniProt</dt>
                    <dd><a href="https://identifiers.org/uniprot:${nodeData.uniprot}" target="_blank">https://identifiers.org/uniprot:${nodeData.uniprot}</a></dd>
                `;
            }

            if (details) {
                for (const [key, value] of Object.entries(details)) {
                    if (['EGID', 'HGNC', 'UP'].includes(key)) continue;
                    dialogContent += `<dt>${key}</dt><dd>${value}</dd>`;
                }
            }

            dialogContent += `</dl>`;
            detailsDialog.innerHTML = dialogContent;

            const pos = network.getPositions([nodeId])[nodeId];
            const domPos = network.canvasToDOM(pos);

            detailsDialog.style.left = `${domPos.x + 30}px`;
            detailsDialog.style.top = `${domPos.y - 30}px`;

            document.body.appendChild(detailsDialog);

            const closeBtn = detailsDialog.querySelector('.close-btn');
            closeBtn.addEventListener('click', function() {
                document.body.removeChild(detailsDialog);
                detailsDialog = null;
            });
        }

        function showEdgeDetails(network, edges, edgeId) {
            if (detailsDialog) {
                document.body.removeChild(detailsDialog);
            }

            detailsDialog = document.createElement('div');
            detailsDialog.className = 'details-dialog';

            const edgeData = edges.get(edgeId);
            const details = edgeData.details || {};

            const beliefScore = typeof details.belief === 'number' ? details.belief.toFixed(2) : 'N/A';

            let content = `
                <span class="close-btn">×</span>
                <h3>Edge Details</h3>
                <dl>
            `;

            // Add appropriate fields based on edge type (statement or regular)
            if (details.statement_type) {
                content += `
                    <dt>Statement Type</dt>
                    <dd>${details.statement_type || 'Unknown'}</dd>
                    <dt>Evidence Count</dt>
                    <dd>${details.evidence_count || 'Unknown'}</dd>
                    <dt>Belief</dt>
                    <dd>${beliefScore}</dd>
                    <dt>INDRA Statement</dt>
                    <dd>${details.indra_statement || 'Unknown'}</dd>
                `;
            } else {
                content += `
                    <dt>belief</dt>
                    <dd>${beliefScore}</dd>
                    <dt>INDRA statement</dt>
                    <dd>${details.indra_statement || 'Unknown'}</dd>
                    <dt>interaction</dt>
                    <dd>${details.interaction || 'Unknown'}</dd>
                    <dt>polarity</dt>
                    <dd>${details.polarity || 'none'}</dd>
                    <dt>supportType</dt>
                    <dd>${details.support_type || 'Unknown'}</dd>
                    <dt>type</dt>
                    <dd>${details.type || 'Unknown'}</dd>
                `;
            }

            content += `</dl>`;
            detailsDialog.innerHTML = content;

            const pos = network.getPositions([edgeData.from, edgeData.to]);
            const fromPos = pos[edgeData.from];
            const toPos = pos[edgeData.to];

            const x = (fromPos.x + toPos.x) / 2;
            const y = (fromPos.y + toPos.y) / 2;

            const domPos = network.canvasToDOM({x: x, y: y});

            detailsDialog.style.left = `${domPos.x + 20}px`;
            detailsDialog.style.top = `${domPos.y + 20}px`;

            document.body.appendChild(detailsDialog);

            const closeBtn = detailsDialog.querySelector('.close-btn');
            closeBtn.addEventListener('click', function() {
                document.body.removeChild(detailsDialog);
                detailsDialog = null;
            });
        }

        function highlightConnections(network, nodes, edges, nodeId) {
            const connectedNodes = network.getConnectedNodes(nodeId);
            const connectedEdges = network.getConnectedEdges(nodeId);

            nodes.get().forEach(node => {
                if (node.id === nodeId) {
                    nodes.update({id: node.id, borderWidth: 4, color: {border: '#FF5722'}});
                } else if (connectedNodes.includes(node.id)) {
                    nodes.update({id: node.id, borderWidth: 3, color: {border: '#FF9800'}});
                } else {
                    nodes.update({id: node.id, opacity: 0.3});
                }
            });

            edges.get().forEach(edge => {
                if (connectedEdges.includes(edge.id)) {
                    edges.update({id: edge.id, width: edge.width * 1.5});
                } else {
                    edges.update({id: edge.id, opacity: 0.1});
                }
            });
        }

        function resetHighlighting(nodes, edges) {
            nodes.get().forEach(node => {
                nodes.update({id: node.id, borderWidth: 2, opacity: 1.0, color: {border: '#37474F'}});
            });

            edges.get().forEach(edge => {
                const originalWidth = edge.width / 1.5;
                edges.update({id: edge.id, width: originalWidth, opacity: 1.0});
            });
        }
    }
    </script>
{% endblock %}